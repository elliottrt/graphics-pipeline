Camera Notes

9/15

see Lectures/PHC.pdf

panning:
	rotate a, b, c about axis passing through <0,0,0>
	direction = -b
	amount = theta
tilt:
	direction = a
rolling:
	direction = c
zooming:
	changing focal length (distance between eye and image plane)

	focal length = c dot (a cross b)

	zoom in: increase focal length
		f = 1.1 * f
		c = c + vd * f * 0.1
			where vd = a cross b
	zoom out: reduce focal length
		f = 0.9 * f
interpolation:
	have the camera follow a path
	interpolate position, rotation, etc. from A to B by delta

	inputs:
		PPC0 has a0, b0, c0, C0
		PPC1 has a1, b1, c1, C1
		index: fi
		index count: fc
	outputs:
		PPC at fi/fc along the path between PPC0, PPC1

	Ci = C0 + (C1-C0) * (fi/(fc-1))
	ai = a0 + (a1-a0) * (fi/(fc-1))
	bi = ... <- these should be calculated based on ai, Ci similar to constructor
	ci = ...

	BUT: interpolation of vectors doesn't preserve angles
		this means a, b might become non-perpendicular, pixels become parallelograms


	note: look at point can be C + view direction
	note: -b can be up direction in vertical plane of camera
	camera, look at point, eye position, up direction in vertical plane of camera (often global y axis)
		C = eye position
		view direction = (look at point - eye position).normalized()
		a = view direction cross up direction in vertical plane of camera
		b = view direction cross a
		c = same computation as constructor
saving/loading:
	save/load a, b, c, C, w, h
visualization:
	draw point at C,
	draw 4 lines where?

9/12

planar pinhole camera
	- pinhole is the position of the camera
	- pixel rectangle is planar

SEE Lectures/PHC.pdf
	pan around -b axis
	tilt around a axis
	roll around c axis

view direction = a cross b

9/10

note: clipping is not required but might be extra credit...
	in this class, we do the bounding box triangle rasterization method
	and if the box is partially/entirely outside of the screen it gets clipped

fov about 85Ëš (option+k)

attributes:
	w: int = width in pixels
	h: int = height in pixels
	C: V3 = camera position
	c: V3 = vector from C to top left of pixel rect
	a: V3 = unit direction of row of pixel rect (goes right)
	b: V3 = unit direction of col of pixel rect (goes down)

	constructor(w, h, horz_fov)
		- doesn't care about position or rotation, that's the user's job

		- C = origin (0, 0, 0)
		- a = x unit vector (1, 0, 0)
		- b = -y unit vector (0, -1, 0)
		- camera looks down the -z axis

		- c = (-w/2, h/2, -focal_length)
			- go out on -z, then up on y, then left on x
			- focal_length is distance from eye to image plane
			- focal_length = w/(2*tan(horz_fov/2))

	transform(...)
		translation
		pitch, yaw, roll

	project_point(P: V3) -> (u, v) | NO_PROJECTION:
		returns pixel position of the point p on the pixel rect

		there isn't always a valid projection.
			- can't see things behind you

		P is on a ray from C to P, we need to find where that ray intersects the screen: P'

		C + (au + bv + c)x = P
			need to find: u, v, x
			3 equations
		M = (a, b, c) <- matrix with a, b, c as columns
		M * <u, v, 1> * x = P - C
			- multiply by inverse of M
		<u, v, 1> * x = M^{-1} * (P-C)

		if x < 0: point is behind camera
		if not (0 <= u < w) point is outside camera
		if not (0 <= v < h) point is outside camera

		if those checks pass: you see the point
